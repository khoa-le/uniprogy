<?php
class WAdminToolsMessage extends UFormWorklet
{	
	public $modelClassName = 'MAdminToolsMessageModel';
	
	public function accessRules()
	{
		return array(
			array('allow', 'roles' => array('administrator')),
			array('deny', 'users'=>array('*'))
		);
	}
	
	public function title()
	{
		return $this->t('Language File Creator');
	}
	
	public function description()
	{
		return $this->t('This tool parses the whole script for words and phrases that need to be translated and returns a language file, which you can translate, upload to the server and get your site shown in another language.');
	}
	
	public function properties()
	{
		return array(
			'activeForm' => array(
				'class'=>'UActiveForm',
				'ajax'=>false
			),
			'description' => $this->description(),
			'elements' => array(
				'path' => array('type' => 'text', 'hint' => $this->t('Which local path should the script search messages in (defaults to application main directory)'), 'class'=>'large'),
				'language' => array('type' => 'text', 'hint' => $this->t('Fill in if you want to re-create language file for existing language. Ex.: en_us')),
			),
			'model' => $this->model,
			'buttons' => array(
				'submit' => array('type' => 'submit', 'label' => $this->t('Create Language File')),
			),
		);
	}
	
	public function afterCreateForm()
	{
		if(!$this->model->path)
			$this->model->path = app()->basePath;
	}
	
	public function taskSave()
	{
		$config=require_once(app()->basePath.DS.'config'.DS.'messages.php');
		$sourcePath = $this->model->path;
		
		if(!is_dir($sourcePath))
			return $this->model->addError('path','The source path $sourcePath is not a valid directory.');

		$messages=array();
		foreach($config as $cfg)
		{
			$options=array();
			if(isset($cfg['fileTypes']))
				$options['fileTypes']=$cfg['fileTypes'];
			if(isset($cfg['exclude']))
				$options['exclude']=$cfg['exclude'];
			$files=CFileHelper::findFiles(realpath($sourcePath),$options);
			foreach($files as $file)
				$messages=array_merge_recursive($messages,$this->extractMessages($file,$cfg));
		}
			
		foreach($messages as $category=>$msgs)
		{
			$msgs=array_values(array_unique($msgs));
			if($this->model->language)
			{
				$fileName = app()->basePath.DS.'messages'.DS.$this->model->language.DS.$category.'.php';
				if(is_file($fileName))
				{
					$translated=require($fileName);
					sort($msgs);
					ksort($translated);
					$merged=array();
					$untranslated=array();
					foreach($msgs as $message)
					{
						if(!empty($translated[$message]))
							$merged[$message]=$translated[$message];
						else
							$untranslated[]=$message;
					}
					ksort($merged);
					sort($untranslated);
					$todo=array();
					foreach($untranslated as $message)
						$todo[$message]='';
					ksort($translated);
					foreach($translated as $message=>$translation)
					{
						if(!isset($merged[$message]) && !isset($todo[$message]))
							$todo[$message]='@@'.$translation.'@@';
					}
					$merged=array_merge($todo,$merged);
				}
			}
			else
			{
				$merged=array();
				foreach($msgs as $message)
					$merged[$message]='';
				ksort($merged);
			}
		}

		$array=str_replace("\r",'',var_export($merged,true));
		$content=<<<EOD
<?php
/**
 * Message translations.
 *
 * This file is automatically generated by 'yiic message' command.
 * It contains the localizable messages extracted from source code.
 * You may modify this file by translating the extracted messages.
 *
 * Each array element represents the translation (value) of a message (key).
 * If the value is empty, the message is considered as not translated.
 * Messages that no longer need translation will have their translations
 * enclosed between a pair of '@@' marks.
 *
 * NOTE, this file must be saved in UTF-8 encoding.
 *
 * @version \$Id: \$
 */
return $array;

EOD;

		$this->send($content);
	}
	
	protected function extractMessages($fileName,$cfg)
	{
		$subject=file_get_contents($fileName);
		$n=preg_match_all($cfg['regex'],$subject,$matches,PREG_SET_ORDER);
		$messages=array();
		for($i=0;$i<$n;++$i)
		{
			if(is_numeric($cfg['index']['category']))
			{
				$category = $matches[$i][$cfg['index']['category']];
				if(($pos=strpos($category,'.'))!==false)
					$category=substr($category,$pos+1,-1);
				else
					$category=substr($category,1,-1);
			}
			else
				$category = $cfg['index']['category'];
				
			$message=$matches[$i][$cfg['index']['message']];
			$messages[$category][]=eval("return $message;");  // use eval to eliminate quote escape
		}
		return $messages;
	}
	
	public function taskSend($content)
	{
		$content_type = "application/octet-stream";
		$filename = 'uniprogy.php';
		
		// disable browser caching
		header('Cache-control: private');
		header('Pragma: private');
		header('Expires: Mon, 26 Jul 1997 05:00:00 GMT');
		
		header('Content-Type: '.$content_type);
		header('Content-Transfer-Encoding: binary');
		header('Content-Length: '.strlen($content));
		header('Content-Disposition: attachment;filename="'.$filename.'"');
		
		echo $content;
		app()->end();
	}
	
	public function taskRenderOutput()
	{
		parent::taskRenderOutput();
		$this->render('instruction');
	}
	
	public function taskBreadCrumbs()
	{
		return array(
			$this->t('Tools') => url('/admin/tools'),
			$this->title()
		);
	}
}